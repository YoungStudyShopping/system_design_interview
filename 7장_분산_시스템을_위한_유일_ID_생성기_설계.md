# 분산 시스템을 위한 유일 ID 생성기 설계

auto_increment 를 생각할 수 있지만, 이는 하나의 DB에서만 고유하며 N개의 DB를 클러스터링하여 사용하는 경우에는 unique 조건이 성립되지 않는다.

## 1. 문제 이해 및 설계 범위 확정

분산 시스템을 위한 유일 ID 생성기 설계를 위한 나이스한 질문은 다음과 같다.

- ID는 고유하나요?
  - 고유하며 정렬가능해야 합니다.
- 새로운 레코드는 항상 1만큼 큰 값이어야 하나요?
  - 시간에 따라 큰값으로 되어야 하는것은 맞지만 무조건 1씩의 차이가 있어야 하는것은 아닙니다.
- ID는 숫자로만 구성되나요? 
  - 네 그렇습니다.
- 시스템 규모는 어느정도일까요?
  - 초당 10,000 ID를 생성할 수 있습니다.


위 질문으로 수립되어지는 요구사항은 다음과 같다.

1. ID는 유일해야한다.
2. ID는 숫자로만 구성되어져야 한다.
3. ID는 64비트로 표현될 수 있는 값이어야 한다.
4. ID는 발급 날짜에 따라 정렬 가능해야 한다.
5. 초당 10,000개의 ID를 만들 수 있어야 한다.

## 2. 개략적 설계안 제시 및 동의 구하기

일반적으로 분산 시스템에서 유일성이 보장되는 ID 생성 방법은 다음과 같다.

1. 다중 마스터 복제
2. UUID
3. 티켓서버
4. 트위터 스노플레이크 접근법


### 2-1) 다중 마스터 복제

DB의 auto_increment 기능을 활용한 방법으로, 노드 갯수를 interval로 잡고 id를 채번하는 방법이다.

예를들어, 2대의 노드가 존재하는 경우
- 1 번노드는 1,3,5 씩 채번.
- 2번 노드는 2,4,6 씩 채번.

이 방식은 규모 확장성 문제를 어느정도 해결할수 있으며 각 DB 노드에서 채번이 이루어지기에 채번이 병렬로 이루어져 성능상 이점을 볼 수 있다.

다만, 다음과 같은 문제도 존재한다.

- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.
- ID 의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞추어 커진다는 보장은 할 수 없다.
- 서버가 추가되거나 삭제되는 경우 정상적인 동작이 되도록 만들기 어렵다.

### 2-2) UUID

UUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트(= 4바이트) 수이다.

UUID는 중복될 일이 지극히 낮다.
> 책에 까르면 1개 충돌이 생길 확률을 50%로 끌어 올리려면 초당 10억개의 UUID 를 100년동안 계속해서 만들어야 한다고 한다..ㅎ

장점은 다음과 같다.

- UUID를 만드는것은 단순하며 노드간 동기화 이슈도 없다.
- 각 서버가 알아서 ID를 만드는 구조이므로 규모 확장도 쉽다.
  
단점은 다음과 같다.
- ID가 128비트로 길다. 이번 요구사항은 64비트이다.
- ID를 시간순으로 정렬할 수 없다.
- ID에 숫자 아닌 값이 포함될 수 있다.

### 2-3) 티켓 서버

ID 생성 서버를 전용으로 두어 각 App에서 티켓서버에 ID 채번을 요구하는 방식이다.

장점
- 유일성이 보장되는 오직 숫자로만 구성된 ID 생성이 쉽다.
- 구현이 쉽고 중소 규모 App에 적합하다.

단점
- SPOF 구조가 된다.
- SPOF 를 피하기위해 티켓서버를 N대를 두게되면 동일하게 동기화 이슈가 다시 나온다.

### 2-4) 트위터 스노플레이크 접근법

트위터 스토플레이크 접근법은 이번 요구사항을 모두 만족할 수 있다.

ID 요구사항이 시간 흐름에 따라 커져야 하며 정렬이 가능해야하는 부분이 있으니 다음과 같이 ID 구조를 가져가도록 하자.

<img width="841" alt="image" src="https://user-images.githubusercontent.com/31622350/166648048-75db4a65-7f0f-4de1-9038-23d5092c092a.png">

- 사인 비트: 1비트로 향후 양수/음수 구분 필요시 사용하도록 둔다.
- 타임스탬프: 41비트로 epoch 이후로 몇 ms가 지났는지 나타내는 값이다.
- 데이터센터 ID: 5비트로 32개까지의 데이터센터를 지원할 수 있다.
- 서버 ID: 5비트로 데이터센터당 32개 서버를 사용할 수 있다.
- 일련번호: 12비트로 각서버에서는 ID 생성 시 이 일련번호를 1만큼 증가시킨다. 이값은 1ms가 경과할때마다 0으로 초기화한다.


### 3. 상세 설계

이제 위에서 마지막으로 살펴본 `트위터 스노플레이크 접근법`의 타임스탬프 부분을 더 살펴본다.

**타임스탬프**

타임스탬프를 나타내는 41비트 값은 다음과 같이 사용되어지게 된다.

<img width="773" alt="image" src="https://user-images.githubusercontent.com/31622350/166648973-1151697f-b02d-4c9c-872e-3eb61952247f.png">

41비트로 표현 가능한 타임스탬프의 최댓값은 대략 69년을 커버할수 있는 값이다.
따라서 69년이 지나면 기원 시각을 바꾸거나 ID 체계를 다른것으로 이전하여야한다.

**일련번호**

일련번호는 12비트로 4096개의 값을 가질 수 있다.

어떤 서버가 같은 밀리초동안 하나 이상의 ID를 만들어낸경우에만 0보다 큰 값을 갖게된다.
> 밀리초마다 0으로 초기화하기에 1ms 동안 4096개 이하로만 채번하면 된다.

### 4. 마무리

면접 때 시간이 남는다면 다음과 같은 부분을 추가로 논의할 수 있다.

- 시계 동기화
- 각 절의 길이 최적화
- 고가용성